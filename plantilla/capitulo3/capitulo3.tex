\chapter{Desarrollo}
\label{chap:cap3}
\section{Experimentos}
\subsection{Tamaño del bloque de memoria}
Como hemos visto anteriormente, la memoria se divide en bloques o sectores. Por las especificaciones del sistema de ficheros, sección \ref{subsec:característicasmemoria}, el tamaño de bloque que manajemos desde el sistema operativo es de 4K. Al no haber encontrado las especificaciones físicas de la memoria, hemos realizado una serie de experimento de ingeniería inversa para tratar de averiguar cúal es el tamaño del sector físico de memoria.

Hicimos varios experimentos, como llenar todo el disco menos 8K, escribir un fichero de 8K, borrarlo, escribir uno de 6K y buscar si quedaban restos del de 8. Nos dimos cuenta de que los 2K restantes estan intactos, como veremos más adelante, los datos y las referias a esos datos se guardan en zonas distintas, sección \ref{subsec:tablanombres}, y al repetir el mismo experimento, los datos habían sido recolocados. Por lo que este método no iba a darnos resultados válidos y por lo tanto no pudimos obtener las conclusiones que queríamos.

Como la idea inicial no funcionó, probamos a mirarlo al revés, copiamos un archivo de un byte y miramos si había cambiado algo más. Para ello primero llenamos el disco con un fichero de  \textit{00} en hexadecimal, y después lo formateamos, código \ref{cod:copiar00formatear}, de esta manera la memoria se queda ``limpia'' para poder tener resultados más fácilmente interpretables. Después de hacer una copia de su imagen actual, copiamos un archivo de un byte con \textit{CC} en hexadecimal. Pero al abrir la imagen con \verb|bless| vimos que no había nada cambiado al rededor de los datos del fichero como podríamos haber podido esperar. 

\lstset{language=bash,
  basicstyle=\ttfamily,
  commentstyle=\color{black}\ttfamily,
  breaklines=true
}
\begin{lstlisting}[caption=Limpiado y formateo de memoria,label=cod:copiar00formatear]
$ ./tam_bloque_b2.sh
$ dd if=datos/datosfin.txt of=/media/cesar/usb2/datos.txt
# umount usb2
# mkfs.vfat /dev/sdc1
# mount -o gid=1000,uid=1000 /dev/sdc1 usb2
\end{lstlisting}
\lstset{language=bash,
  basicstyle=\ttfamily,
  commentstyle=\color{green}\ttfamily,
  breaklines=true
}

Por último probamos a grabar dos archivos de 2 bytes y mirar ``cúanto'' se separan. El tamaño de bloque será el espacio que queda entre ambos ficheros en memoria.

\begin{verbatim}
$ ./archivos_marcados_b3.sh
$ ./tam_bloque_b2.sh
$ dd if=datos/datosfin.txt of=/media/cesar/4F35-D764/datosfin
$ cp datos2/datos1.txt /media/cesar/4F35-D764/datos1.txt
$ cp datos2/datos1.txt /media/cesar/4F35-D764/datos2.txt
$ sudo dd if=/dev/sdb1 of=tambloque.iso
\end{verbatim}

Al copiar los veces el mismo archivo tuvimos el problema que no encontrábamos los archivos, así que lo repetimos pero el segundo archivo que copiamos contenia \textit{BB}. Pero nos encontramos con otro problema, \verb|bless| solo encontraba el fichero con los datos \textit{CC}, figura \ref{fig:tambloqueCC}, pero no el que contenia \textit{BB}.

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth,natwidth=610,natheight=642]{fig/tambloqueCC.png}
	\caption{\emph{Fichero con CC para calcular el tamaño de sector}}
        \label{fig:tambloqueCC}
\end{figure}

Así que repetimos el experimento, después de haber aplicado el proceso de limpieza, código \ref{cod:copiar00formatear}, copiando dos ficheros con distintos datos, código \ref{cod:ficherosbbcc}. Y este fue el resultado de que obtuvimos:

Lo primero que encontramos es la tabla de nombre con la referencia a los ficheros, figura \ref{fig:nombreCCBBtamVacio}, veremos más sobre cómo funciona esta tabla en la sección \ref{subsec:tablanombres}. Como puede verse en las figuras \ref{fig:datosCCtamVacio} y \ref{fig:datosBBtamVacio} los datos empiezan en la posición 7692288 y 7696384 respectivamente, hemos puesto el offset de \verb|bless| para que muestre la posición de bit, por lo que su separación es de 4096 bits, que es lo mismo a 4Kbytes. Por lo que el controlador no recoloca los datos en este sentido, respeta el tamaño de bloque que tiene el sistema de ficheros Fat32 que como ya hemos visto es de 4K.

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth,natwidth=610,natheight=642]{fig/nombreCCBBtamVacio.png}
	\caption{\emph{Tabla de nombre con los ficheros}}
        \label{fig:nombreCCBBtamVacio}
\end{figure}

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth,natwidth=610,natheight=642]{fig/datosCCtamVacio.png}
	\caption{\emph{Fichero con CC para calcular el tamaño de sector}}
        \label{fig:datosCCtamVacio}
\end{figure}

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth,natwidth=610,natheight=642]{fig/datosBBtamVacio.png}
	\caption{\emph{Fichero con BB para calcular el tamaño de sector}}
        \label{fig:datosBBtamVacio}
\end{figure}

\begin{lstlisting}[caption=Creación de ficheros con datos distintos para el tamaño de bloque,label=cod:ficherosbbcc]
$ echo -e -n ``\xBB'' > datosBB.txt
$ cat datosBB.txt >> datosBBBB.txt
$ cat datosBB.txt >> datosBBBB.txt
$ echo -e -n ``\xCC'' > datosCC.txt
$ cat datosCC.txt >> datosCCCC.txt
$ cat datosCC.txt >> datosCCCC.txt
\end{lstlisting}

\subsection{Tabla de nombres}
\label{subsec:tablanombres}


\subsection{Movimiendo de datos entre sectores}



\subsection{Vida útil}

Después de varias pruebas con el script \verb|flash_b2.sh| \ref{cod:flash_b2} y \verb|flash_b3.sh| \ref{cod:flash_b3} no conseguimos el resultado esperado, que es obtener datos para generar una gráfica que muestre como disminuye la capacidad según se van deteriorando bloques de memoria.

Al principio pensamos que como este tipo de memorias tienen bloques reservados para que el deterioro de la capacidad no se vea reflejado, pues nosotros tampoco erámos capaces de verlo. Entonces hicimos pruebas más largas para evitar este posible problema. Pero solo conseguimos que la memoria diese errores de entrada/salida y la memoria dejase de estar accesible Figura \ref{fig:errorlectura}.

En una prueba con una memoria con el estado inicial, Listing \ref{cod:estadoinicialmemoria}, llegamos a realizar 50.356.021 ciclos de escritura/borrado antes de registrar algún error. Como se puede ver en las últimas líneas del log \ref{cod:flashFinal2} del script donde vamos apuntado cada ciclo de escritura/borrado y el estado de la memoria.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth,natwidth=610,natheight=642]{fig/errorlectura.png}
	\caption{\emph{Errores de lectura en la memoria}}
        \label{fig:errorlectura}
\end{figure}

\begin{lstlisting}[caption=Estado inicial de la memoria,label=cod:estadoinicialmemoria]
$ df --block-size=KB
Filesystem 1kB-blocks  Used   Available Use\% Mounted on
/dev/sde1   3924005kB  5kB    3924000kB   1\% /media/cesar/usb3
\end{lstlisting}

\begin{lstlisting}[caption=Log del script \ref{cod:flash_b2},label=cod:flashFinal2]
$ tail stam.txt
Filesystem     1K-blocks      Used Available Use\% Mounted on
/dev/sde1      3924005kB 2189669kB 1734337kB  56\% /media/74A8-CE74
vuelta  50356019
/dev/sde1      3924005kB 2189669kB 1734337kB  56\% /media/74A8-CE74
vuelta  50356020
/dev/sde1      3924005kB 2189669kB 1734337kB  56\% /media/74A8-CE74
vuelta  50356021
\end{lstlisting}

Lo que quiere decir, que la capacidad de la memoria no se ha visto afecta después de 50.356.021 ciclos de escritura/borrado. También buscamos errores en el syslog del kernel y este fue el registro que obtuvimos \ref{cod:logkernel}. Lo que nos da a suponer que algo del sistema de ficheros o del controlador se ha corrompido, pero la memoria sigue intacta.

\begin{lstlisting}[caption=Log del kernel cuando se produce el error en el sistema de ficheros,label=cod:logkernel]
 kern.log:May 15 19:32:56 donatello kernel: [1699652.958924] FAT: Filesystem error (dev sde1)
 kern.log:May 15 19:32:56 donatello kernel: [1699652.972408] FAT: Filesystem error (dev sde1)
 kern.log:May 15 19:32:56 donatello kernel: [1699652.972426] FAT: Filesystem error (dev sde1)
 kern.log:May 15 19:51:50 donatello kernel: [1700786.560947] sd 12:0:0:0: [sde] Attached SCSI removable disk
 messages:May 15 19:51:50 donatello kernel: [1700786.560947] sd 12:0:0:0: [sde] Attached SCSI removable disk
 syslog:May 15 19:32:56 donatello kernel: [1699652.958924] FAT: Filesystem error (dev sde1)
 syslog:May 15 19:32:56 donatello kernel: [1699652.972408] FAT: Filesystem error (dev sde1)
 syslog:May 15 19:32:56 donatello kernel: [1699652.972426] FAT: Filesystem error (dev sde1)
 syslog:May 15 19:51:50 donatello kernel: [1700786.560947] sd 12:0:0:0: [sde] Attached SCSI removable disk
\end{lstlisting}

En otros dos casos, no conseguimos obtener datos en el momento que la memoria empezó a fallar. Pero quedo completamente inservible, ya que aunque el sistema lo reconoce \ref{cod:logsistema}, ni mantiene las particiones originales \ref{cod:fdiskroto}, ni se puede acceder a ella.

\begin{lstlisting}[caption=Log del sistema con memoria dañada,label=cod:logsistema]
  [ 4673.313154] usb 3-1: new high-speed USB device number 3 using 
ehci-pci
  [ 4673.444924] usb-storage 3-1:1.0: USB Mass Storage device 
detected
  [ 4673.446328] scsi3 : usb-storage 3-1:1.0
\end{lstlisting}

\lstset{language=bash,
  basicstyle=\ttfamily,
  commentstyle=\color{black}\ttfamily,
  breaklines=true
}
\begin{lstlisting}[caption=Salida del fdisk,label=cod:fdiskroto]
  # fdisk /dev/sdc
  Device does not contain a recognized partition table.
  Created a new DOS disklabel with disk identifier 0x1670df5f.
\end{lstlisting}
\lstset{language=bash,
  basicstyle=\ttfamily,
  commentstyle=\color{green}\ttfamily,
  breaklines=true
}

\begin{verbatim}
$ df
Filesystem     1K-blocks      Used Available Use% Mounted on
/dev/sdc1        3831940    716640   3115300  19% /media/cesar/usb1
\end{verbatim}


Vamos a llenar el dispositivo con un fichero con \textit{00}. Después borramos el archivo y copiamos un archivo de 64K que contiene \textit{CC}. Hacemos una imagen \verb|.iso| de la memoria, borramos el fichero, creamos otra imagen, volvemos a copiar el mismo archivo y hacemos otra imagen del dispositivo.
\begin{verbatim}
$ ./archivos_marcados_b3.sh
$ ./tam_bloque_b2.sh
$ dd if=datos/datosfin.txt of=/media/cesar/4F35-D764/datosfin.txt
$ rm /media/cesar/4F35-D764/datosfin.txt
$ cp datos2/datos16.txt /media/cesar/4F35-D764/
$ sudo dd if=/dev/sdb1 of=datos16.iso
$ rm /media/cesar/4F35-D764/datos16.txt
$ sudo dd if=/dev/sdb1 of=datos16borrado.iso
$ cp datos2/datos16.txt /media/cesar/4F35-D764/
$ sudo dd if=/dev/sdb1 of=datos16copiado.iso
\end{verbatim}

Con \verb|bless| hemos visto que los datos siguen estado después de haber borrado el fichero. Pero \verb|md5sum| nos dice que las imágenes sin distintas, así que vamos a crear ficheros de texto con \verb|hexdum| para poder comparar las imágenes con \verb|meld|.
\begin{verbatim}
$ md5sum *
5b47c568523dbb3bb3128e3f4193148d  datos16.iso
5704c3cc3b5264aecfc5e5a4a54f0bf5  datos16borrado.iso
9fbc3200e1f61767c5c0da7353fe1c72  datos16copiado.iso
\end{verbatim}

\section{Código}
\verb|archivos_marcados_b3.sh|
\begin{lstlisting}[caption=Script que genera datos de varios tamaños,label=cod:archivos_marcados_b3]
#
# Crea ficheros de todos los tamaños posibles hasta llegar a 'valor_final'
#
valor_final=3907388
((tamfinal=valor_final*1024))

aux=2
cont=0
while [ $aux -le  $tamfinal ]; do

	((aux=aux+aux))
	((cont++))
done

echo "auxiliar" $aux
echo "contado" $cont
rm datos/*
echo -e -n "\x00" > datos/datos0.txt

((aux=cont))

echo "vamos a contar desde 1 a " $aux

for (( a=1 ; a<=aux ; a++ ))
do
	((b=a-1))
	cat datos/datos$b.txt > datos/datos$a.txt
	cat datos/datos$b.txt >> datos/datos$a.txt
	echo $b
	echo $a
done
\end{lstlisting}


\verb|flash_b2.sh|
\begin{lstlisting}[caption=Script para flashear una memoria con un fichero un gran número de veces,label=cod:flash_b2]
#
# 
#
dispo="4E06-0AB9"
sdd="sdb"
rm stam.txt	
for (( b=0 ; b<999999999999999999999 ;b++))
do
	let vueltas=$b

for (( a=1 ; a<3 ; a++ ))
do
	echo "numero serie ${b}_${a}"
	echo -e -n "numero serie ${b}_${a}" > datos/${b}_${a}datos.txt
	for (( c=1 ; c<200 ; c++ ))
	do
		echo -e -n "numero serie ${b}_${a}" >> 
datos/${b}_${a}datos.txt
	done
	#cat datos/datos.txt >> datos/${b}_${a}datos.txt
	#echo -e -n "numero serie ${b}_${a}" >> datos/${b}_${a}datos.txt
	dd if=datos/${b}_${a}datos.txt 
of=/media/${dispo}/${b}_${a}datos.txt
	rm datos/*_*datos.txt
done

rm -f /media/${dispo}/*datos.txt

df --block-size=KB | grep ${sdd} >> stam.txt
#cut -c32-52 tam.txt >> stam.txt

frase="vuelta "
echo "$frase $vueltas" >> stam.txt
echo " " >> stam.txt

#sudo umount /media/usb0
#sudo mount /dev/sdc1 /media/usb0

done
\end{lstlisting}


\verb|flash_b3.sh|
\begin{lstlisting}[caption=Script para flashear una memoria con un archivo fácil de encontrar,label=cod:flash_b3]
#
# Crea un fichero con un texto reconocible y su numero de serie
#
rm stam.txt
rm diff.txt
for (( b=0 ; b<10 ;b++))
do
	let vueltas=$b

for (( a=1 ; a<3 ; a++ ))
do
	echo "numero serie ${b}_${a}"
	echo -e -n "En un lugar de la Mancha, de cuyo nombre no quiero 
acordarme, no ha mucho tiempo que vivía un hidalgo de los de lanza en astillero, adarga antigua, rocín flaco y galgo corredor. Una olla de algo más vaca que carnero, salpicón las más 
noches, duelos y quebrantos los sábados, lentejas los viernes, algún palomino de añadidura los domingos, consumían las tres partes de su 
hacienda. El resto della concluían sayo de velarte, calzas de velludo para las fiestas con sus pantuflos de lo mismo, los días de entre 
semana se honraba con su vellori de lo más fino. Tenía en su casa una ama que pasaba de los cuarenta, y una sobrina que no llegaba a los 
veinte, y un mozo de campo y plaza, que así ensillaba el rocín como tomaba la podadera. Frisaba la edad de nuestro hidalgo con los 
cincuenta años, era de complexión recia, seco de carnes, enjuto de rostro; gran madrugador y amigo de la caza. Quieren decir que tenía el 
sobrenombre de Quijada o Quesada (que en esto hay alguna diferencia en los autores que deste caso escriben), aunque por conjeturas 
verosímiles se deja entender que se llama Quijana; pero esto importa poco a nuestro cuento; basta que en la narración dél no se salga un 
punto de la verdad. ${b}_${a}" > datos/${b}_${a}datos.txt
	#cat datos/datos.txt >> datos/${b}_${a}datos.txt
	#echo -e -n "numero serie ${b}_${a}" >> datos/${b}_${a}datos.txt
	dd if=datos/${b}_${a}datos.txt of=/media/usb0/${b}_${a}datos.txt
	rm datos/*_*datos.txt
done

dd if=/dev/sdc1 of=copias/${b}.iso

echo "vuelta ${b}" >> diff.txt

if (($b != 0 ))
then
((c=b-1))
cmp -l copias/${b}.iso copias/${c}.iso >> diff.txt
fi

echo "" >> diff.txt

rm -f /media/usb0/*datos.txt

df --block-size=KB | grep sdc1 > tam.txt
cut -c32-52 tam.txt >> stam.txt

frase="vuelta "
echo "$frase $vueltas" >> stam.txt
echo " " >> stam.txt

done
\end{lstlisting}

\verb|mount.sh|
\begin{lstlisting}[caption=Script para verificar si en el montado y desmontado existe movimiento de datos,label=cod:mount]
rm md5.txt

for (( a=1 ; a<999999999999999 ; a++ ))
do
	sudo umount /media/usb0
	sudo mount /dev/sdb1 /media/usb0
	echo "$a" >> md5.txt
	dd if=/dev/sdb1 | md5sum >> md5.txt

done
\end{lstlisting}

\verb|tam_bloque_b1.sh|
\begin{lstlisting}[caption=Script para generar ficheros de un tamaño concreto,label=cod:tam_bloque_b1]
df --block-size=KiB | grep sdb1 > tam.txt
tam_final=$(cut -c56-63 tam.txt)
echo $tam_final
((valor_final=tam_final-6))
((valor_final_bits=valor_final*1024))
echo "valor final" $valor_final_bits
final_binario=$(echo "obase=2; $valor_final_bits"| bc)
echo $final_binario > long.txt
echo "valor en binario" $final_binario
long=${#final_binario}


((long--))

total=0

((exp=long))

for ((a=1;a<=long;a++))
do
bit=$(cut -c$a-$a long.txt)
#echo "a="$a "bit sacado de long.txt" $bit
if((bit==1))
then
	((exponente=2**exp))
#	echo "exponente" $exp
	echo $exp $exponente
	((total=total+exponente))
	
	cat datos/datos$exp.txt >> datos/datosfin.txt
fi
((exp--))
done

echo $total
\end{lstlisting}

\verb|tam_bloque_b2.sh|
\begin{lstlisting}[caption=Script para generar ficheros de un tamaño concreto,label=cod:tam_bloque_b2]
((valor_final=3907388))
#((valor_final=3907388/4))
((valor_final_bits=valor_final*1024))
echo "valor final" $valor_final_bits
final_binario=$(echo "obase=2; $valor_final_bits"| bc)
echo $final_binario > long.txt
echo "valor en binario" $final_binario
long=${#final_binario}


((long--))

total=0

((exp=long))
rm datos/datosfin.txt
for ((a=1;a<=long;a++))
do
bit=$(cut -c$a-$a long.txt)
#echo "a="$a "bit sacado de long.txt" $bit
if((bit==1))
then
	((exponente=2**exp))
#	echo "exponente" $exp
	echo $exp $exponente
	((total=total+exponente))
	
	cat datos/datos$exp.txt >> datos/datosfin.txt
fi
((exp--))
done

echo $total
\end{lstlisting}
